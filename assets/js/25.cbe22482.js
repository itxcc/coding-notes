(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{419:function(t,e,v){"use strict";v.r(e);var _=v(1),r=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"图片懒加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#图片懒加载"}},[t._v("#")]),t._v(" 图片懒加载")]),t._v(" "),v("p",[t._v("图片”懒“加载其实就是延时加载，原理就是判断图片当前的位置是否在你看的区域里。")]),t._v(" "),v("p",[t._v("实现一个图片懒加载涉及到JavaScript的知识点：视口位置判断、防抖节流")]),t._v(" "),v("h2",{attrs:{id:"懒加载原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#懒加载原理"}},[t._v("#")]),t._v(" 懒加载原理")]),t._v(" "),v("p",[t._v("图片能够被用户看到，是因为浏览器向服务器发出了请求，能够发出请求是根据"),v("code",[t._v("<img>")]),t._v("标签中"),v("code",[t._v("src")]),t._v("属性是否存在。")]),t._v(" "),v("p",[t._v("那么我们就让初始的"),v("code",[t._v("<img>")]),t._v("标签所有"),v("code",[t._v("src")]),t._v("属性都为空，判断当图片的位置进入到可视区域中的时候去给"),v("code",[t._v("<img>")]),t._v("标签赋值"),v("code",[t._v("src")]),t._v("属性，这样就实现懒加载了。")]),t._v(" "),v("h2",{attrs:{id:"懒加载的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#懒加载的实现"}},[t._v("#")]),t._v(" 懒加载的实现")]),t._v(" "),v("h2",{attrs:{id:"方法一"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法一"}},[t._v("#")]),t._v(" 方法一")]),t._v(" "),v("ol",[v("li",[t._v("通过"),v("code",[t._v("document.documentElement.clientHeight")]),t._v("获取屏幕可视窗口高度")]),t._v(" "),v("li",[t._v("通过"),v("code",[t._v("element.offsetTop")]),t._v("获取元素相对于文档顶部的距离")]),t._v(" "),v("li",[t._v("通过"),v("code",[t._v("document.documentElement.scrollTop")]),t._v("获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离")])]),t._v(" "),v("p",[t._v("公式：元素距离文档顶部的距离-滚动条滚动的具体<屏幕可视窗口高度 = 2-1<3")]),t._v(" "),v("p",[t._v("缺点：只适用于下拉的时候去判断，如果当前在页面最底部，用户跳转到其他页面，返回过来还在最底部的话，就会加载所有的图片了")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://itxcc.github.io/demo/lazy-loading/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Demo"),v("OutboundLink")],1)]),t._v(" "),v("h2",{attrs:{id:"方法二"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法二"}},[t._v("#")]),t._v(" 方法二")]),t._v(" "),v("p",[t._v("利用"),v("code",[t._v("getBoundingClientRect()")]),t._v("方法来获取元素的大小以及位置，这个方法返回一个名为"),v("code",[t._v("ClientRect")]),t._v("的"),v("code",[t._v("DOMRect")]),t._v("对象，包含了"),v("code",[t._v("top")]),t._v("、"),v("code",[t._v("right")]),t._v("、"),v("code",[t._v("botton")]),t._v("、"),v("code",[t._v("left")]),t._v("、"),v("code",[t._v("width")]),t._v("、"),v("code",[t._v("height")]),t._v("这些值。")]),t._v(" "),v("p",[t._v("MDN上有这样一张图：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://mdn.mozillademos.org/files/15087/rect.png",alt:"img"}})]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("let rect = el.getBoundingClientRect() //元素的距离各位方向的距离\nlet viewHeight = document.documentElement.clientHeight； // 屏幕可视窗口高度\n")])])]),v("p",[t._v("也就是说"),v("code",[t._v("rect.top = viewHeight")]),t._v("时，说明元素的顶部刚好在可视窗口的底部，那么"),v("code",[t._v("rect.top < viewHeight")]),t._v("时，元素就肯定在可视窗口内了。")]),t._v(" "),v("p",[t._v("公式："),v("code",[t._v("rect.top < viewHeight")])]),t._v(" "),v("p",[t._v("问题来了：在方法一种如果页面在底部，我们去刷新就会一直加载全部的图片。就要确保这个元素确确实实要在我们的可视窗口内，从上图中可以看到，再加一个判断，"),v("code",[t._v("rect.bottom")]),t._v(">="),v("code",[t._v("0")])]),t._v(" "),v("p",[t._v("升级我们的公式：")]),t._v(" "),v("p",[t._v("公式："),v("code",[t._v("rect.top < viewHeight && rect.bottom >= 0")])]),t._v(" "),v("p",[v("a",{attrs:{href:"https://itxcc.github.io/demo/lazy-loading/index1.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Demo"),v("OutboundLink")],1)]),t._v(" "),v("h2",{attrs:{id:"方法三"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法三"}},[t._v("#")]),t._v(" 方法三")]),t._v(" "),v("p",[v("code",[t._v("IntersectionObserver")]),t._v("可以自动观察元素是否在视口内。")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("var io = new IntersectionObserver(callback, option);\n// 开始观察\nio.observe(document.getElementById('example'));\n// 停止观察\nio.unobserve(element);\n// 关闭观察器\nio.disconnect();\n")])])]),v("p",[t._v("callback的参数是一个数组，每个数组都是一个"),v("code",[t._v("IntersectionObserverEntry")]),t._v("对象，包括以下属性：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("属性")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("time")]),t._v(" "),v("td",[t._v("可见性发生变化的时间，单位为毫秒")])]),t._v(" "),v("tr",[v("td",[t._v("rootBounds")]),t._v(" "),v("td",[t._v("与getBoundingClientRect()方法的返回值一样")])]),t._v(" "),v("tr",[v("td",[t._v("boundingClientRect")]),t._v(" "),v("td",[t._v("目标元素的矩形区域的信息")])]),t._v(" "),v("tr",[v("td",[t._v("intersectionRect")]),t._v(" "),v("td",[t._v("目标元素与视口（或根元素）的交叉区域的信息")])]),t._v(" "),v("tr",[v("td",[t._v("intersectionRatio")]),t._v(" "),v("td",[t._v("目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0")])]),t._v(" "),v("tr",[v("td",[t._v("target")]),t._v(" "),v("td",[t._v("被观察的目标元素，是一个 DOM 节点对象")])])])]),t._v(" "),v("p",[t._v("我们需要用到"),v("code",[t._v("intersectionRatio")]),t._v("来判断是否在可视区域内，当"),v("code",[t._v("intersectionRatio > 0 && intersectionRatio <= 1")]),t._v("即在可视区域内。")]),t._v(" "),v("p",[t._v("公式："),v("code",[t._v("intersectionRatio > 0 && intersectionRatio <= 1")])]),t._v(" "),v("p",[v("a",{attrs:{href:"https://itxcc.github.io/demo/lazy-loading/index2.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Demo"),v("OutboundLink")],1)]),t._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),v("ul",[v("li",[v("p",[v("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("阮一峰：IntersectionObserver API 使用教程"),v("OutboundLink")],1)])]),t._v(" "),v("li",[v("p",[v("a",{attrs:{href:"https://blog.csdn.net/ITzhongzi/article/details/77466779",target:"_blank",rel:"noopener noreferrer"}},[t._v("原生JS实现最简单的图片懒加载"),v("OutboundLink")],1)])])])])}),[],!1,null,null,null);e.default=r.exports}}]);